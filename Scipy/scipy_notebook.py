# -*- coding: utf-8 -*-
"""scipy_notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vt6AiuV00HK-pigHSN8lO0ACQLbSnXJc
"""

!pip install scipy

print(sp.__version__)

from scipy import constants as constants
import scipy as sp
print(const.liter)

"""## Metric (SI) Prefixes:
Return the specified unit in meter (e.g. centi returns 0.01)
"""

print(f"yotta = {constants.yotta}")    # 1e+24
print(f"zetta = {constants.zetta}")    # 1e+21
print(f"exa = {constants.exa}")        # 1e+18
print(f"peta = {constants.peta}")      # 1000000000000000.0
print(f"tera = {constants.tera}")      # 1000000000000.0
print(f"giga = {constants.giga}")      # 1000000000.0
print(f"mega = {constants.mega}")      # 1000000.0
print(f"kilo = {constants.kilo}")      # 1000.0
print(f"hecto = {constants.hecto}")    # 100.0
print(f"deka = {constants.deka}")      # 10.0
print(f"deci = {constants.deci}")      # 0.1
print(f"centi = {constants.centi}")    # 0.01
print(f"milli = {constants.milli}")    # 0.001
print(f"micro = {constants.micro}")    # 1e-06
print(f"nano = {constants.nano}")      # 1e-09
print(f"pico = {constants.pico}")      # 1e-12
print(f"femto = {constants.femto}")    # 1e-15
print(f"atto = {constants.atto}")      # 1e-18
print(f"zepto = {constants.zepto}")    # 1e-21

"""## Binary constants
Return the specified unit in bytes (e.g. kibi returns 1024)
"""

print(f"kibi = {constants.kibi}")    # 1024
print(f"mebi = {constants.mebi}")    # 1048576
print(f"gibi = {constants.gibi}")    # 1073741824
print(f"tebi = {constants.tebi}")    # 1099511627776
print(f"pebi = {constants.pebi}")    # 1125899906842624
print(f"exbi = {constants.exbi}")    # 1152921504606846976
print(f"zebi = {constants.zebi}")    # 1180591620717411303424
print(f"yobi = {constants.yobi}")    # 1208925819614629174706176

"""## Mass
Return the specified unit in kg (e.g. gram returns 0.001)
"""

print(f"gram = {constants.gram} kg")             # 0.001 kg
print(f"metric_ton = {constants.metric_ton} kg") # 1000.0 kg
print(f"grain = {constants.grain} kg")           # 6.479891e-05 kg
print(f"lb = {constants.lb} kg")                 # 0.45359236999999997 kg
print(f"pound = {constants.pound} kg")           # 0.45359236999999997 kg
print(f"oz = {constants.oz} kg")                 # 0.028349523124999998 kg
print(f"ounce = {constants.ounce} kg")           # 0.028349523124999998 kg
print(f"stone = {constants.stone} kg")           # 6.3502931799999995 kg
print(f"long_ton = {constants.long_ton} kg")     # 1016.0469088 kg
print(f"short_ton = {constants.short_ton} kg")   # 907.1847399999999 kg
print(f"troy_ounce = {constants.troy_ounce} kg") # 0.031103476799999998 kg
print(f"troy_pound = {constants.troy_pound} kg") # 0.37324172159999996 kg
print(f"carat = {constants.carat} kg")           # 0.0002 kg
print(f"atomic_mass = {constants.atomic_mass} kg") # 1.66053904e-27 kg
print(f"m_u = {constants.m_u} kg")               # 1.66053904e-27 kg
print(f"u = {constants.u} kg")                   # 1.66053904e-27 kg

"""## Angle:
Return the specified unit in radians (e.g. degree returns 0.017453292519943295)
"""

from scipy import constants

print(f"degree = {constants.degree} radians")         # 0.017453292519943295 radians
print(f"arcmin = {constants.arcmin} radians")         # 0.0002908882086657216 radians
print(f"arcminute = {constants.arcminute} radians")   # 0.0002908882086657216 radians
print(f"arcsec = {constants.arcsec} radians")         # 4.84813681109536e-06 radians
print(f"arcsecond = {constants.arcsecond} radians")   # 4.84813681109536e-06 radians

"""## Time:
Return the specified unit in seconds (e.g. hour returns 3600.0)
"""

print(f"minute = {constants.minute} seconds")         # 60.0 seconds
print(f"hour = {constants.hour} seconds")             # 3600.0 seconds
print(f"day = {constants.day} seconds")               # 86400.0 seconds
print(f"week = {constants.week} seconds")             # 604800.0 seconds
print(f"year = {constants.year} seconds")             # 31536000.0 seconds
print(f"Julian_year = {constants.Julian_year} seconds")  # 31557600.0 seconds

"""## Length:
Return the specified unit in meters (e.g. nautical_mile returns 1852.0)
"""

print(f"inch = {constants.inch} meters")                        # 0.0254 meters
print(f"foot = {constants.foot} meters")                        # 0.30479999999999996 meters
print(f"yard = {constants.yard} meters")                        # 0.9143999999999999 meters
print(f"mile = {constants.mile} meters")                        # 1609.3439999999998 meters
print(f"mil = {constants.mil} meters")                          # 2.5399999999999997e-05 meters
print(f"pt = {constants.pt} meters")                            # 0.00035277777777777776 meters
print(f"point = {constants.point} meters")                      # 0.00035277777777777776 meters
print(f"survey_foot = {constants.survey_foot} meters")          # 0.3048006096012192 meters
print(f"survey_mile = {constants.survey_mile} meters")          # 1609.3472186944373 meters
print(f"nautical_mile = {constants.nautical_mile} meters")      # 1852.0 meters
print(f"fermi = {constants.fermi} meters")                      # 1e-15 meters
print(f"angstrom = {constants.angstrom} meters")                # 1e-10 meters
print(f"micron = {constants.micron} meters")                    # 1e-06 meters
print(f"au = {constants.au} meters")                            # 149597870691.0 meters
print(f"astronomical_unit = {constants.astronomical_unit} meters")  # 149597870691.0 meters
print(f"light_year = {constants.light_year} meters")            # 9460730472580800.0 meters
print(f"parsec = {constants.parsec} meters")                    # 3.0856775813057292e+16 meters

"""## Pressure:
Return the specified unit in pascals (e.g. psi returns 6894.757293168361)
"""

print(f"atm = {constants.atm} Pa")             # 101325.0 Pa
print(f"atmosphere = {constants.atmosphere} Pa")  # 101325.0 Pa
print(f"bar = {constants.bar} Pa")             # 100000.0 Pa
print(f"torr = {constants.torr} Pa")           # 133.32236842105263 Pa
print(f"mmHg = {constants.mmHg} Pa")           # 133.32236842105263 Pa
print(f"psi = {constants.psi} Pa")             # 6894.757293168361 Pa

"""## Area:
Return the specified unit in square meters(e.g. hectare returns 10000.0)
"""

print(f"hectare = {constants.hectare} m²")   # 10000.0 m²
print(f"acre = {constants.acre} m²")         # 4046.8564223999992 m²

"""## Volume:
Return the specified unit in cubic meters (e.g. liter returns 0.001)
"""

print(f"liter = {constants.litre} m³")
print(f"gallon = {constants.gallon} m³")
print(f"gallon_US = {constants.gallon_US} m³")
print(f"gallon_imp = {constants.gallon_imp} m³")
print(f"fluid_ounce = {constants.fluid_ounce} m³")
print(f"fluid_ounce_US = {constants.fluid_ounce_US} m³")
print(f"fluid_ounce_imp = {constants.fluid_ounce_imp} m³")
print(f"barrel = {constants.barrel} m³")
print(f"bbl = {constants.bbl} m³")

"""## Speed:
Return the specified unit in meters per second (e.g. speed_of_sound returns 340.5)
"""

print(f"kmh = {constants.kmh} m/s")              # 0.2777777777777778 m/s
print(f"mph = {constants.mph} m/s")              # 0.44703999999999994 m/s
print(f"mach = {constants.mach}")                # 340.5 (dimensionless)
print(f"speed_of_sound = {constants.speed_of_sound} m/s")  # 340.5 m/s
print(f"knot = {constants.knot} m/s")           # 0.5144444444444445 m/s

"""## Temperature
Return the specified unit in Kelvin (e.g. zero_Celsius returns 273.15)
"""

print(f"zero_Celsius = {constants.zero_Celsius} K")           # 273.15 K
print(f"degree_Fahrenheit = {constants.degree_Fahrenheit} K")  # 0.5555555555555556 K

"""## Energy:
Return the specified unit in joules (e.g. calorie returns 4.184)
"""

print(f"eV = {constants.eV} joules")               # 1.6021766208e-19 joules
print(f"electron_volt = {constants.electron_volt} joules")  # 1.6021766208e-19 joules
print(f"calorie = {constants.calorie} joules")     # 4.184 joules
print(f"calorie_th = {constants.calorie_th} joules")  # 4.184 joules
print(f"calorie_IT = {constants.calorie_IT} joules")  # 4.1868 joules
print(f"erg = {constants.erg} joules")             # 1e-07 joules
print(f"Btu = {constants.Btu} joules")             # 1055.05585262 joules
print(f"Btu_IT = {constants.Btu_IT} joules")      # 1055.05585262 joules
print(f"Btu_th = {constants.Btu_th} joules")      # 1054.3502644888888 joules
print(f"ton_TNT = {constants.ton_TNT} joules")    # 4184000000.0 joules

"""## Power:
Return the specified unit in watts (e.g. horsepower returns 745.6998715822701)
"""

print(f"hp = {constants.hp} watts")                # 745.6998715822701 watts
print(f"horsepower = {constants.horsepower} watts")  # 745.6998715822701 watts

"""## Force:
Return the specified unit in newton (e.g. kilogram_force returns 9.80665)
"""

print(f"dyn = {constants.dyn} N")                     # 1e-05 N
print(f"dyne = {constants.dyne} N")                   # 1e-05 N
print(f"lbf = {constants.lbf} N")                     # 4.4482216152605 N
print(f"pound_force = {constants.pound_force} N")     # 4.4482216152605 N
print(f"kgf = {constants.kgf} N")                     # 9.80665 N
print(f"kilogram_force = {constants.kilogram_force} N")  # 9.80665 N

from scipy.optimize import root
from math import cos

def eqn(x):
  return x + 2*cos(x)




myroot = root(eqn, 0)

print(myroot.x)

"""## Minimizing a Function
A function, in this context, represents a curve, curves have high points and low points.

High points are called maxima.

Low points are called minima.

The highest point in the whole curve is called global maxima, whereas the rest of them are called local maxima.

The lowest point in whole curve is called global minima, whereas the rest of them are called local minima
"""

from scipy.optimize import minimize

def eqn(x):
  return x**2 + x + 2

mymin = minimize(eqn, 0, method='BFGS')

print(mymin)

"""## How to Work With Sparse Data
SciPy has a module, scipy.sparse that provides functions to deal with sparse data.

There are primarily two types of sparse matrices that we use:

CSC - Compressed Sparse Column. For efficient arithmetic, fast column slicing.

CSR - Compressed Sparse Row. For fast row slicing, faster matrix vector products

We will use the CSR matrix in this tutorial.
"""

import numpy as np
from scipy.sparse import csr_matrix

arr = np.array([0, 0, 0, 0, 0, 1, 1, 0, 2])

print(csr_matrix(arr))

"""From the result we can see that there are 3 items with value.

The 1. item is in row 0 position 5 and has the value 1.

The 2. item is in row 0 position 6 and has the value 1.

The 3. item is in row 0 position 8 and has the value 2.
"""

arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])

print(csr_matrix(arr))
print("Printing only data values of the sparse matrix : ",csr_matrix(arr).data)
print("Printing numbers of non_zero values of the sparse matrix : ",csr_matrix(arr).count_nonzero())

# Removing zero-entries from the matrix with the eliminate_zeros() method:
arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])

mat = csr_matrix(arr)
mat.eliminate_zeros()

print(mat)

arr = np.array([[0, 0, 0], [0, 0, 1], [1, 0, 2]])

mat = csr_matrix(arr)
mat.sum_duplicates()
print("CSR Matrix")
print(mat)
print("CSC Matrix")
print(mat.tocsc())

"""## Adjacency Matrix
Adjacency matrix is a nxn matrix where n is the number of elements in a graph.

And the values represents the connection between the elements.

Example:
For a graph like this, with elements A, B and C, the connections are:

A & B are connected with weight 1.

A & C are connected with weight 2.

C & B is not connected.

The Adjency Matrix would look like this:

        A B C
     A:[0 1 2]  
     B:[1 0 0]
     C:[2 0 0]

### Connected Components
Find all of the connected components with the connected_components() method.
"""

import numpy as np
from scipy.sparse.csgraph import connected_components
from scipy.sparse import csr_matrix

# Create a 2D NumPy array representing an undirected graph
arr = np.array([
  [0, 1, 2],
  [1, 0, 0],
  [2, 0, 0]
])

# Convert the NumPy array to a CSR matrix
newarr = csr_matrix(arr)

# Use connected_components to find the connected components
components, labels = connected_components(newarr)

# Print the result
print("Number of connected components:", components)
print("Labels for each node:", labels)

"""### Dijkstra
Use the dijkstra method to find the shortest path in a graph from one element to another.

It takes following arguments:

1. return_predecessors: boolean (True to return whole path of traversal otherwise False).
2. indices: index of the element to return all paths from that element only.
3. limit: max weight of path.
"""

import numpy as np
from scipy.sparse.csgraph import dijkstra
from scipy.sparse import csr_matrix

# Create a 2D NumPy array representing a weighted directed graph
arr = np.array([
    [0, 1, 2],
    [1, 0, 0],
    [2, 0, 0]
])

# Convert the NumPy array to a CSR matrix
newarr = csr_matrix(arr)

# Use Dijkstra's algorithm to find the shortest paths
# from node with index 0 to all other nodes
shortest_paths, predecessors = dijkstra(newarr, return_predecessors=True, indices=0)

# Print the result
print("Shortest paths:", shortest_paths)
print("Predecessors:", predecessors)

import numpy as np
from scipy.sparse.csgraph import dijkstra
from scipy.sparse import csr_matrix

# Create a 2D NumPy array representing a weighted directed graph
arr = np.array([
    [0, 1, 2, 0, 0, 0],
    [1, 0, 0, 1, 1, 0],
    [2, 0, 0, 0, 0, 2],
    [0, 1, 0, 0, 0, 0],
    [0, 1, 0, 2, 0, 1],
    [0, 0, 2, 0, 1, 0]
])

# Convert the NumPy array to a CSR matrix
newarr = csr_matrix(arr)

# Use Dijkstra's algorithm to find the shortest paths
# from node with index 0 to all other nodes
shortest_paths, predecessors = dijkstra(newarr, return_predecessors=True, indices=0)

# Print the graph
print("Weighted Directed Graph:")
print(arr)

# Print the result
print("\nShortest paths:")
print(shortest_paths)
print("\nPredecessors:")
print(predecessors)

# Reconstruct and print the shortest paths to all nodes
for destination_node in range(1, len(arr)):
    path = [destination_node]
    while predecessors[destination_node] != -9999:
        destination_node = predecessors[destination_node]
        path.insert(0, destination_node)
    print(f"Shortest path to node {path[-1]}: {path}")

import numpy as np
from scipy.sparse.csgraph import floyd_warshall
from scipy.sparse import csr_matrix

# Create a 2D NumPy array representing a weighted directed graph
arr = np.array([
    [0, 1, 2, 0, 0, 0],
    [1, 0, 0, 1, 1, 0],
    [2, 0, 0, 0, 0, 2],
    [0, 1, 0, 0, 0, 0],
    [0, 1, 0, 2, 0, 1],
    [0, 0, 2, 0, 1, 0]
])

# Convert the NumPy array to a CSR matrix
graph_matrix = csr_matrix(arr)

# Use Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes
all_shortest_paths, predecessors = floyd_warshall(graph_matrix, directed=True, return_predecessors=True)

# Print the graph
print("Weighted Directed Graph:")
print(arr)

# Print the shortest paths between all pairs of nodes
print("\nAll Shortest Paths:")
print(all_shortest_paths)

# Reconstruct and print the shortest paths for specific nodes
source_node = 0
for destination_node in range(1, len(arr)):
    shortest_path = all_shortest_paths[source_node, destination_node]
    print(f"Shortest path from node {source_node} to node {destination_node}: {shortest_path}")

"""### Triangulation
A Triangulation of a polygon is to divide the polygon into multiple triangles with which we can compute an area of the polygon.

A Triangulation with points means creating surface composed triangles in which all of the given points are on at least one vertex of any triangle in the surface.

One method to generate these triangulations through points is the Delaunay() Triangulation.
"""

import numpy as np
from scipy.spatial import Delaunay
import matplotlib.pyplot as plt

points = np.array([
  [2, 4],
  [3, 4],
  [3, 0],
  [2, 2],
  [4, 1]
])

simplices = Delaunay(points).simplices
print(simplices)
plt.triplot(points[:, 0], points[:, 1], simplices)
plt.scatter(points[:, 0], points[:, 1], color='r')

plt.show()

"""### Convex Hull
A convex hull is the smallest polygon that covers all of the given points.

Use the ConvexHull() method to create a Convex Hull.
"""

import numpy as np
from scipy.spatial import ConvexHull
import matplotlib.pyplot as plt

points = np.array([
  [2, 4],
  [3, 4],
  [3, 0],
  [2, 2],
  [4, 1],
  [1, 2],
  [5, 0],
  [3, 1],
  # [1, 2],
  [0, 2]
])

hull = ConvexHull(points)
hull_points = hull.simplices

plt.scatter(points[:,0], points[:,1])
for simplex in hull_points:
  plt.plot(points[simplex,0], points[simplex,1], 'k-')

plt.show()

"""#### Singular value Decomposition"""

import numpy
x = numpy.random.randn(2, 3)
for i, m in enumerate(numpy.linalg.svd(x)):
  if i==0:
    print("Orthogonal U\n",m)
  elif i==1:
    print("Singular values E \n",m)
  else:
    print("Orthogonal V^T\n",m)

